    ```cocaine```
const cocaineSpasm = () => {
    if (!ig?.game?.O4269) return setTimeout(cocaineSpasm, 500);
    let p = ig.game.O4269;
    let oldKill = p.kill.bind(p);
    let old = p.update.bind(p);

    // prevent death initially
    p.kill = function() {}; 

    // Spasm toggle
    let spasmActive = true;
    setInterval(() => { spasmActive = !spasmActive; }, 30000);

    const canvas = document.querySelector('canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    let hue = 0;
    let elapsed = 0;

    // Gradually drain health over 25 seconds
    const drainDuration = 25000; // ms
    const drainInterval = 100; // ms
    const steps = drainDuration / drainInterval;
    const initialHealth = p.health ?? 100; 
    const drainAmount = initialHealth / steps;

    const healthDrain = setInterval(() => {
        elapsed += drainInterval;
        if (p.health !== undefined) {
            p.health -= drainAmount;
            if (p.health <= 0) {
                clearInterval(healthDrain);
                p.kill = oldKill;
                p.kill();
            }
        }
    }, drainInterval);

    const liquidWarp = () => {
        const w = canvas.width;
        const h = canvas.height;

        // Capture current canvas frame
        const frame = ctx.getImageData(0, 0, w, h);
        const srcData = new Uint8ClampedArray(frame.data);

        // Gradually increase amplitude over time
        const amplitude = 5 + 10 * Math.min(elapsed / drainDuration, 1); // 5 â†’ 15 max
        const frequency = 0.02;

        for (let y = 0; y < h; y++) {
            const offset = Math.floor(Math.sin((y + hue) * frequency) * amplitude);
            for (let x = 0; x < w; x++) {
                let dstX = x + offset;
                if (dstX < 0) dstX = 0;
                if (dstX >= w) dstX = w - 1;

                const srcIdx = (y * w + x) * 4;
                const dstIdx = (y * w + dstX) * 4;

                frame.data[dstIdx] = srcData[srcIdx];
                frame.data[dstIdx + 1] = srcData[srcIdx + 1];
                frame.data[dstIdx + 2] = srcData[srcIdx + 2];
                frame.data[dstIdx + 3] = srcData[srcIdx + 3];
            }
        }

        ctx.putImageData(frame, 0, 0);

        // color chaos
        hue += 2;
        canvas.style.filter = `hue-rotate(${hue}deg) saturate(1.5)`;
        canvas.style.transform = `scale(${1 + Math.sin(hue/30)*0.02}) rotate(${Math.sin(hue/20)*0.5}deg)`;

        requestAnimationFrame(liquidWarp);
    };
    liquidWarp();

    p.update = function() {
        if (spasmActive) {
            this.gravityFactor = 0;

            const s = 1600;
            if (ig.input.state('left'))  this.vel.x = -s;
            if (ig.input.state('right')) this.vel.x = s;
            if (ig.input.state('up'))    this.vel.y = -s;
            if (ig.input.state('down'))  this.vel.y = s;

            if (!ig.input.state('left') && !ig.input.state('right')) this.vel.x *= 0.7;
            if (!ig.input.state('up') && !ig.input.state('down'))   this.vel.y *= 0.7;

            this.pos.x += (Math.random() - 0.5) * 20;
            this.pos.y += (Math.random() - 0.5) * 20;

            if (this._rot === undefined) this._rot = 0;
            this._rot += (Math.random() - 0.5) * 0.4;
            if ('angle' in this) this.angle = this._rot;
        } else {
            this.gravityFactor = 1;
            this.vel.x *= 0.95;
            this.vel.y *= 0.95;
        }

        old();
    };
};

cocaineSpasm();
