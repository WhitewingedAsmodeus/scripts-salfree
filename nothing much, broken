(async () => {
    if (typeof Jimp === 'undefined') {
        await new Promise(resolve => $.getScript('https://cdnjs.cloudflare.com/ajax/libs/jimp/0.12.0/jimp.min.js', resolve));
    }

    class MLImage {
        constructor(jImage) {
            this.jImage = jImage;
            this.flatImage = null;
            this.palette = null;
            this.paletteImage = null;
        }

        get w() { return this.jImage.bitmap.width; }
        get h() { return this.jImage.bitmap.height; }

        flatten() {
            const d = this.jImage.bitmap.data;
            this.flatImage = [];
            for (let y = 0; y < this.h; y++) {
                for (let x = 0; x < this.w; x++) {
                    const idx = (y * this.w + x) * 4;
                    this.flatImage.push([d[idx], d[idx + 1], d[idx + 2], d[idx + 3]]);
                }
            }
            return this.flatImage;
        }

        getPalette() {
            this.flatImage ??= this.flatten();
            const palette = [];
            const seen = {};
            const maxColors = 50;
            for (const px of this.flatImage) {
                if (px[3] <= 10) continue;
                const key = `${px[0]},${px[1]},${px[2]}`;
                if (!seen[key]) {
                    seen[key] = true;
                    palette.push({ r:px[0], g:px[1], b:px[2], a:255 });
                    if (palette.length >= maxColors) break;
                }
            }
            this.palette = palette;
            return this.palette;
        }

        palettize() {
            this.getPalette();
            this.paletteImage = this.flatImage.map(px => {
                if (px[3] <= 10) return -1;
                let bestIdx = 0;
                let bestDist = Infinity;
                for (let i = 0; i < this.palette.length; i++) {
                    const c = this.palette[i];
                    const dist = Math.pow(px[0]-c.r,2)+Math.pow(px[1]-c.g,2)+Math.pow(px[2]-c.b,2);
                    if (dist < bestDist) { bestDist = dist; bestIdx = i; }
                }
                return bestIdx;
            });
        }

        getPixelIndex(x, y) { return x + y * this.w; }
        getPixelPIndex(x, y) {
            const idx = this.paletteImage?.[this.getPixelIndex(x, y)];
            return (idx !== undefined && idx >= 0) ? idx : -1;
        }
    }

    async function writeToPainter(img) {
        const p = ig.game.painter;
        if (!p) { console.error("Painter not ready"); return; }
        p.data ??= {};
        const pd = p.data;
        pd.colors ??= [];
        pd.pixels ??= [];

        const isDynamic = pd.type === 'dynamicThing';

        if (!img.paletteImage) img.palettize();

        const slotMapping = [];
        let slot = 0;
        for (let i = 0; i < img.palette.length; i++) {
            while ([11, 12].includes(slot)) slot++; // skip 11 and 12
            pd.colors[slot] = img.palette[i];
            slotMapping[i] = slot;
            slot++;
        }

        // For normal import
        const frame = [];
        for (let y = 0; y < img.h; y++) {
            const row = [];
            for (let x = 0; x < img.w; x++) {
                const pix = img.getPixelPIndex(x, y);
                row.push(pix >= 0 ? slotMapping[pix] : 11);
            }
            frame.push(row);
        }

        // If dynamic, cut into 9 cells (3x3 grid of 29x29)
        if (isDynamic) {
            const cellSize = 29;
            const cells = [];
            for (let cy = 0; cy < 3; cy++) {
                for (let cx = 0; cx < 3; cx++) {
                    const startX = cx * cellSize;
                    const startY = cy * cellSize;
                    const cell = [];
                    for (let y = 0; y < cellSize; y++) {
                        const row = [];
                        for (let x = 0; x < cellSize; x++) {
                            const px = img.getPixelPIndex(startX + x, startY + y);
                            row.push(px >= 0 ? slotMapping[px] : 11);
                        }
                        cell.push(row);
                    }
                    cells.push(cell);
                }
            }
            pd.pixels = cells;
            pd.text = "0s: cell 2 right 29, cell 3 right 58, cell 4 down 29, cell 5 down 29, cell 5 right 29, cell 6 down 29, cell 6 right 58, cell 7 down 58, cell 8 down 58, cell 8 right 29, cell 9 down 58, cell 9 right 58, cell 1 show, cell 2 show, cell 3 show, cell 4 show, cell 5 show, cell 6 show, cell 7 show, cell 8 show, cell 9 show";
            console.log("ðŸ§© Dynamic mode enabled â€” 9 cells applied & custom Saltfree code written");
        } else {
            pd.pixels = [frame];
        }

        p.update?.();
        console.log(`âœ… Imported (${img.palette.length} colors, skipping 11&12, dynamic: ${isDynamic})`);
    }

    async function pixelCopyFromImgur(url) {
        let jImg = await Jimp.read(url);

        const maxSize = 200;
        const { width, height } = jImg.bitmap;
        if (width > maxSize || height > maxSize) {
            const scale = maxSize / Math.max(width, height);
            jImg.resize(Math.round(width * scale), Math.round(height * scale));
            console.log(`âš¡ Resized to ${jImg.bitmap.width}x${jImg.bitmap.height}`);
        }

        const img = new MLImage(jImg);
        img.flatten();
        img.palettize();
        await writeToPainter(img);
    }

    // Example use
    await pixelCopyFromImgur('YOUR_IMAGE_URL_HERE');
})();
